
# Redis
BigKey 问题
OOM, 存储不均衡， 查询慢（占带宽), 删除慢

字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。  
非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。

redis-cli --bigkeys  有风险! 在slave 本机执行，避免网络开销.  
可以使用 --i 0.1 代表100毫秒执行一次  

debug object ${key}命令获取键值的相关信息

# 数据类型和底层数据结构
![](img/db_redis_1.png)
+ 字符串String 
    + int 编码：保存的是可以用 long 类型表示的整数值。
    + embstr 编码：保存长度小于44字节的字符串（before redis3.2 39字节）。
    + raw 编码：保存长度大于44字节的字符串（before redis3.2 39字节）。 
+ 集合Set  
+ 哈希Hash  
+ 列表List  
+ 有序集SortedSet    
    + 使用ziplist 编码：保存的元素数量小于128； 保存的所有元素长度都小于64字节    
    + 其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独使用 字典，虽然能 以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1)的复杂度变为了O(logN)
 
+ 简单动态字符串（SDS）  
+ 字典   
+ 链表  
+ 跳跃表  
    * 有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大。
    * 每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点。
    * 每一层的每一个每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针。
    * 如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点。
+ 整数集合  
+ 压缩列表  


# 多实例使用模式
## 集群模式
三主， 多从（备）

优点  
1.  无中心架构，数据按照slot分布在多个节点。  
2.  集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。  
3.  可线性扩展到1000多个节点，节点可动态添加或删除  
4.  能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换
   
缺点  
1. 客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”  
2. 节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的  
3. 数据通过异步复制，不保证数据的强一致性  
4. slave充当“冷备”，不能缓解读压力  
5. 批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好  
6. key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能  
7. 不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0  


## 主从复制模式 
一主多从，读写分离  
优点： 
 master能自动将数据同步到slave，可以进行读写分离，分担master的读压力  
 master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求  
缺点:  
 不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复
 master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
 难以支持在线扩容，Redis的容量受限于单机配置

## Sentinel（哨兵）模式
基于主从复制模式，只是引入了哨兵来监控与自动处理故障。

优点:  
 哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有
 哨兵模式下，master挂掉可以自动进行切换，系统可用性更高  
缺点：  
 同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置
 需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务

# 实用案例
## Redis做异步队列
使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。  
可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 
能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。    
pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

## redis如何实现延时队列
使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。  
