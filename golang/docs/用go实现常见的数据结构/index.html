<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://maosher.github.io/golang/docs/%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>1 golang常见数据结构实现 - My Read Note</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">My Read Note</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../../.." class="nav-link">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">编程语言 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">C++</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../cpp/cpp11/" class="dropdown-item">C++11</a>
</li>
            
<li>
    <a href="../../../cpp/knowledge/" class="dropdown-item">Knowledge Point</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Golang</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../goroutine/" class="dropdown-item">Goroutine</a>
</li>
            
<li>
    <a href="../../defer/" class="dropdown-item">Defer</a>
</li>
            
<li>
    <a href="../../gc/" class="dropdown-item">GC</a>
</li>
            
<li>
    <a href="../../feature/" class="dropdown-item">Feature</a>
</li>
            
<li>
    <a href="../../slice/" class="dropdown-item">Slice & Array</a>
</li>
            
<li>
    <a href="../../experience/" class="dropdown-item">Project Experience</a>
</li>
            
<li>
    <a href="../../common_mistake/" class="dropdown-item">常见错误</a>
</li>
            
<li>
    <a href="../../about/" class="dropdown-item">Think About</a>
</li>
            
<li>
    <a href="../" class="dropdown-item">一些文章</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Lua</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../lua/c/" class="dropdown-item">Lua 和 c</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Algorithm <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../al/tree/" class="dropdown-item">Tree</a>
</li>
                                    
<li>
    <a href="../../../al/code/" class="dropdown-item">Code</a>
</li>
                                    
<li>
    <a href="../../../al/skiplist/" class="dropdown-item">SkipList</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Network & OS <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../os/tools/" class="dropdown-item">Tools</a>
</li>
                                    
<li>
    <a href="../../../os/tcp/" class="dropdown-item">Tcp</a>
</li>
                                    
<li>
    <a href="../../../os/shell/" class="dropdown-item">Linux shell</a>
</li>
                                    
<li>
    <a href="../../../os/memory/" class="dropdown-item">Memory</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">数据库和消息队列 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../db/mysql/" class="dropdown-item">Mysql</a>
</li>
                                    
<li>
    <a href="../../../db/kv/" class="dropdown-item">KV</a>
</li>
                                    
<li>
    <a href="../../../db/mongodb/" class="dropdown-item">MongoDb</a>
</li>
                                    
<li>
    <a href="../../../third_party/mq/" class="dropdown-item">MessageQueue</a>
</li>
                                    
<li>
    <a href="../../../third_party/etcd/" class="dropdown-item">Etcd</a>
</li>
                                    
<li>
    <a href="../../../third_party/tools/" class="dropdown-item">Tools</a>
</li>
                                    
<li>
    <a href="../../../devops/docker/" class="dropdown-item">Docker</a>
</li>
                                    
<li>
    <a href="../../../git/" class="dropdown-item">Git</a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../../../links/" class="nav-link">Links</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#1-golang" class="nav-link">1 golang常见数据结构实现</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#11" class="nav-link">1.1 链表</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#12" class="nav-link">1.2 可变数组</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#13" class="nav-link">1.3 栈和队列</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#14-mapset" class="nav-link">1.4 字典Map和集合Set</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#15" class="nav-link">1.5 二叉树</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="1-golang">1 golang常见数据结构实现</h1>
<h2 id="11">1.1 链表</h2>
<p>举单链表的例子，双向链表同理只是多了pre指针。</p>
<p>定义单链表结构：</p>
<pre><code class="language-go">type LinkNode struct {
    Data     int64
    NextNode *LinkNode
}
</code></pre>
<p>构造链表及打印链表：</p>
<pre><code class="language-go">func main() {

    node := new(LinkNode)
    node.Data = 1

    node1 := new(LinkNode)
    node1.Data = 2
    node.NextNode = node1 // node1 链接到 node 节点上

    node2 := new(LinkNode)
    node2.Data = 3
    node1.NextNode = node2 // node2 链接到 node1 节点上

    // 顺序打印。把原链表头结点赋值到新的NowNode上
    // 这样仍然保留了原链表头结点node不变
    nowNode := node
    for nowNode != nil {
        fmt.Println(nowNode.Data)
        // 获取下一个节点。链表向下滑动
        nowNode = nowNode.NextNode
    }
}
</code></pre>
<h2 id="12">1.2 可变数组</h2>
<p>可变数组在各种语言中都非常常用，在golang中，可变数组语言本身已经实现，就是我们的切片slice。</p>
<h2 id="13">1.3 栈和队列</h2>
<h3 id="131">1.3.1 原生切片实现栈和队列</h3>
<p>栈：先进后出，后进先出，类似弹夹</p>
<p>队列：先进先出</p>
<p>golang中，实现并发不安全的栈和队列，非常简单，我们直接使用原生切片即可。</p>
<h4 id="1311">1.3.1.1 切片原生栈实现</h4>
<pre><code class="language-go">func main() {
    // 用切片制作一个栈
    var stack []int
    // 元素1 入栈
    stack = append(stack, 1, 5, 7, 2)
    // 栈取出最近添加的数据。例如[1,5,7,2] ，len = 4
    x := stack[len(stack)-1] // 2
    // 切掉最近添加的数据，上一步和这一步模仿栈的pop。
    stack = stack[:len(stack)-1] // [1,5,7]
    fmt.Printf(&quot;%d&quot;, x)
}
</code></pre>
<h4 id="1312">1.3.1.2 切片原生队列实现</h4>
<pre><code class="language-go">func main() {

    // 用切片模仿队列
    var queue []int
    // 进队列
    queue = append(queue, 1, 5, 7, 2)
    // 队头弹出，再把队头切掉，模仿队列的poll操作
    cur := queue[0]
    queue = queue[1:]

    fmt.Printf(&quot;%d&quot;, cur)
}
</code></pre>
<h3 id="132">1.3.2 并发安全的栈和队列</h3>
<h4 id="1321">1.3.2.1 切片实现并发安全的栈</h4>
<ul>
<li>并发安全的栈</li>
</ul>
<pre><code class="language-go">// 数组栈，后进先出
type Mystack struct {
    array []string   // 底层切片
    size  int        // 栈的元素数量
    lock  sync.Mutex // 为了并发安全使用的锁
}
</code></pre>
<ul>
<li>入栈</li>
</ul>
<pre><code class="language-go">// 入栈
func (stack *Mytack) Push(v string) {
    stack.lock.Lock()
    defer stack.lock.Unlock()

    // 放入切片中，后进的元素放在数组最后面
    stack.array = append(stack.array, v)

    // 栈中元素数量+1
    stack.size = stack.size + 1
}
</code></pre>
<ul>
<li>出栈</li>
</ul>
<p>1、如果切片偏移量向前移动 stack.array[0 : stack.size-1]，表明最后的元素已经不属于该数组了，数组变相的缩容了。此时，切片被缩容的部分并不会被回收，仍然占用着空间，所以空间复杂度较高，但操作的时间复杂度为：O(1)。</p>
<p>2、如果我们创建新的数组 newArray，然后把老数组的元素复制到新数组，就不会占用多余的空间，但移动次数过多，时间复杂度为：O(n)。</p>
<pre><code class="language-go">func (stack *Mystack) Pop() string {
    stack.lock.Lock()
    defer stack.lock.Unlock()

    // 栈中元素已空
    if stack.size == 0 {
        panic(&quot;empty&quot;)
    }

    // 栈顶元素
    v := stack.array[stack.size-1]

    // 切片收缩，但可能占用空间越来越大
    //stack.array = stack.array[0 : stack.size-1]

    // 创建新的数组，空间占用不会越来越大，但可能移动元素次数过多
    newArray := make([]string, stack.size-1, stack.size-1)
    for i := 0; i &lt; stack.size-1; i++ {
        newArray[i] = stack.array[i]
    }
    stack.array = newArray

    // 栈中元素数量-1
    stack.size = stack.size - 1
    return v
}
</code></pre>
<ul>
<li>获取栈顶元素</li>
</ul>
<pre><code class="language-go">// 获取栈顶元素
func (stack *Mystack) Peek() string {
    // 栈中元素已空
    if stack.size == 0 {
        panic(&quot;empty&quot;)
    }

    // 栈顶元素值
    v := stack.array[stack.size-1]
    return v
}
</code></pre>
<ul>
<li>获取栈大小和判定是否为空</li>
</ul>
<pre><code class="language-go">// 栈大小
func (stack *Mystack) Size() int {
    return stack.size
}

// 栈是否为空
func (stack *Mystack) IsEmpty() bool {
    return stack.size == 0
}
</code></pre>
<h4 id="1322">1.3.2.2 切片实现并发安全的队列</h4>
<ul>
<li>队列结构</li>
</ul>
<pre><code class="language-go">// 数组队列，先进先出
type Myqueue struct {
    array []string   // 底层切片
    size  int        // 队列的元素数量
    lock  sync.Mutex // 为了并发安全使用的锁
}
</code></pre>
<ul>
<li>入队</li>
</ul>
<pre><code class="language-go">// 入队
func (queue *Myqueue) Add(v string) {
    queue.lock.Lock()
    defer queue.lock.Unlock()

    // 放入切片中，后进的元素放在数组最后面
    queue.array = append(queue.array, v)

    // 队中元素数量+1
    queue.size = queue.size + 1
}
</code></pre>
<ul>
<li>出队</li>
</ul>
<p>1、原地挪位，依次补位 queue.array[i-1] = queue.array[i]，然后数组缩容：queue.array = queue.array[0 : queue.size-1]，但是这样切片缩容的那部分内存空间不会释放。</p>
<p>2、创建新的数组，将老数组中除第一个元素以外的元素移动到新数组。</p>
<pre><code class="language-go">// 出队
func (queue *Myqueue) Remove() string {
    queue.lock.Lock()
    defer queue.lock.Unlock()

    // 队中元素已空
    if queue.size == 0 {
        panic(&quot;empty&quot;)
    }

    // 队列最前面元素
    v := queue.array[0]

    /*    直接原位移动，但缩容后继的空间不会被释放
        for i := 1; i &lt; queue.size; i++ {
            // 从第一位开始进行数据移动
            queue.array[i-1] = queue.array[i]
        }
        // 原数组缩容
        queue.array = queue.array[0 : queue.size-1]
    */

    // 创建新的数组，移动次数过多
    newArray := make([]string, queue.size-1, queue.size-1)
    for i := 1; i &lt; queue.size; i++ {
        // 从老数组的第一位开始进行数据移动
        newArray[i-1] = queue.array[i]
    }
    queue.array = newArray

    // 队中元素数量-1
    queue.size = queue.size - 1
    return v
}
</code></pre>
<h2 id="14-mapset">1.4 字典Map和集合Set</h2>
<h3 id="141-map">1.4.1 Map</h3>
<p>字典也是程序语言经常使用的结构，golang中的字典是其自身实现的map结构。具体操作可以查看语言api</p>
<p>并发安全的map，可以定义结构，结构中有一个map成员和一个锁变量成员，参考并发安全的栈和队列的实现。go语言也实现了一个并发安全的map,具体参考sync.map的api</p>
<h3 id="142-set">1.4.2 Set</h3>
<p>我们可以借助map的特性，实现一个Set结构。</p>
<ul>
<li>Set结构</li>
</ul>
<p>map的值我们不适用，定义为空的结构体struct{}</p>
<pre><code class="language-go">// 集合结构体
type Set struct {
    m            map[int]struct{} // 用字典来实现，因为字段键不能重复
    len          int          // 集合的大小
    sync.RWMutex              // 锁，实现并发安全
}
</code></pre>
<ul>
<li>初始化Set</li>
</ul>
<pre><code class="language-go">// 新建一个空集合
func NewSet(cap int64) *Set {
    temp := make(map[int]struct{}, cap)
    return &amp;Set{
        m: temp,
    }
}
</code></pre>
<ul>
<li>往set中添加一个元素</li>
</ul>
<pre><code class="language-go">// 增加一个元素
func (s *Set) Add(item int) {
    s.Lock()
    defer s.Unlock()
    s.m[item] = struct{}{} // 实际往字典添加这个键
    s.len = len(s.m)       // 重新计算元素数量
}
</code></pre>
<ul>
<li>删除一个元素</li>
</ul>
<pre><code class="language-go">// 移除一个元素
func (s *Set) Remove(item int) {
    s.Lock()
    s.Unlock()

    // 集合没元素直接返回
    if s.len == 0 {
        return
    }

    delete(s.m, item) // 实际从字典删除这个键
    s.len = len(s.m)  // 重新计算元素数量
}
</code></pre>
<ul>
<li>查看元素是否在集合set中</li>
</ul>
<pre><code class="language-go">// 查看是否存在元素
func (s *Set) Has(item int) bool {
    s.RLock()
    defer s.RUnlock()
    _, ok := s.m[item]
    return ok
}
</code></pre>
<ul>
<li>查看集合大小</li>
</ul>
<pre><code class="language-go">// 查看集合大小
func (s *Set) Len() int {
    return s.len
}
</code></pre>
<ul>
<li>查看集合是否为空</li>
</ul>
<pre><code class="language-go">// 集合是够为空
func (s *Set) IsEmpty() bool {
    if s.Len() == 0 {
        return true
    }
    return false
}
</code></pre>
<ul>
<li>清除集合所有元素</li>
</ul>
<pre><code class="language-go">// 清除集合所有元素
func (s *Set) Clear() {
    s.Lock()
    defer s.Unlock()
    s.m = map[int]struct{}{} // 字典重新赋值
    s.len = 0                // 大小归零
}
</code></pre>
<ul>
<li>将集合转化为切片</li>
</ul>
<pre><code class="language-go">func (s *Set) List() []int {
    s.RLock()
    defer s.RUnlock()
    list := make([]int, 0, s.len)
    for item := range s.m {
        list = append(list, item)
    }
    return list
}
</code></pre>
<h2 id="15">1.5 二叉树</h2>
<p>二叉树：每个节点最多只有两个儿子节点的树。</p>
<p>满二叉树：叶子节点与叶子节点之间的高度差为 0 的二叉树，即整棵树是满的，树呈满三角形结构。在国外的定义，非叶子节点儿子都是满的树就是满二叉树。我们以国内为准。</p>
<p>完全二叉树：完全二叉树是由满二叉树而引出来的，设二叉树的深度为 k，除第 k 层外，其他各层的节点数都达到最大值，且第 k 层所有的节点都连续集中在最左边。</p>
<ul>
<li>二叉树结构定义</li>
</ul>
<pre><code class="language-go">// 二叉树
type TreeNode struct {
    Data  string    // 节点用来存放数据
    Left  *TreeNode // 左子树
    Right *TreeNode // 右字树
}
</code></pre>
<ul>
<li>树的遍历</li>
</ul>
<p>1、先序遍历：先访问根节点，再访问左子树，最后访问右子树。</p>
<p>2、后序遍历：先访问左子树，再访问右子树，最后访问根节点。</p>
<p>3、中序遍历：先访问左子树，再访问根节点，最后访问右子树。</p>
<p>4、层次遍历：每一层从左到右访问每一个节点。</p>
<pre><code class="language-go">// 先序遍历
func PreOrder(tree *TreeNode) {
    if tree == nil {
        return
    }

    // 先打印根节点
    fmt.Print(tree.Data, &quot; &quot;)
    // 再打印左子树
    PreOrder(tree.Left)
    // 再打印右字树
    PreOrder(tree.Right)
}

// 中序遍历
func MidOrder(tree *TreeNode) {
    if tree == nil {
        return
    }

    // 先打印左子树
    MidOrder(tree.Left)
    // 再打印根节点
    fmt.Print(tree.Data, &quot; &quot;)
    // 再打印右字树
    MidOrder(tree.Right)
}

// 后序遍历
func PostOrder(tree *TreeNode) {
    if tree == nil {
        return
    }

    // 先打印左子树
    MidOrder(tree.Left)
    // 再打印右字树
    MidOrder(tree.Right)
    // 再打印根节点
    fmt.Print(tree.Data, &quot; &quot;)
}
</code></pre>
<p>按层遍历：</p>
<pre><code class="language-go">func Level(head *TreeNode) {

    if head == nil {
        return
    }

    // 用切片模仿队列
    var queue []*TreeNode
    queue = append(queue, head)

    for len(queue) != 0 {
        // 队头弹出，再把队头切掉，模仿队列的poll操作
        cur := queue[0]
        queue = queue[1:]

        fmt.Printf(&quot;%d&quot;, (*cur).Data)

        // 当前节点有左孩子，加入左孩子进队列
        if cur.Left != nil {
            queue = append(queue, cur.Left)
        }

        // 当前节点有右孩子，加入右孩子进队列
        if cur.Right != nil {
            queue = append(queue, cur.Right)
        }
    }

}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
