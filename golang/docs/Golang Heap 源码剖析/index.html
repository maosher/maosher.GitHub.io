<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="https://maosher.github.io/golang/docs/Golang%20Heap%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>堆原理解析 - My Read Note</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../../css/theme.css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u5806\u539f\u7406\u89e3\u6790";
    var mkdocs_page_input_path = "golang\\docs\\Golang Heap \u6e90\u7801\u5256\u6790.md";
    var mkdocs_page_url = "/golang/docs/Golang%20Heap%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/";
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> My Read Note</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../git/">Git</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">C++</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../cpp/cpp11/">C++11</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../cpp/knowledge/">Knowledge Point</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Golang</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../goroutine/">Goroutine</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../defer/">Defer</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../gc/">GC</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../feature/">Feature</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../slice/">Slice & Array</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../experience/">Project Experience</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../common_mistake/">常见错误</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../about/">Think About</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../">一些文章</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Lua</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../lua/c/">Lua 和 c</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Algorithm</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../al/tree/">Tree</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../al/code/">Code</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../al/skiplist/">SkipList</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Network & OS</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../os/tools/">Tools</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../os/tcp/">Tcp</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../os/shell/">Linux shell</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../os/memory/">Memory</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Database</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../db/mysql/">Mysql</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../db/kv/">KV</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../db/mongodb/">MongoDb</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">ThirdParty</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../third_party/mq/">MessageQueue</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../third_party/etcd/">Etcd</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../third_party/tools/">Tools</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Game Design</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../game/framework/">Framework</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../game/map/">Map</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Dev Ops</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../devops/docker/">Docker</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../links/">Links</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../about/">About</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">My Read Note</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
    
    <li>堆原理解析</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="_1">堆原理解析</h1>
<p>堆一般指二叉堆。是使用完全二叉树这种数据结构构建的一种实际应用。通过它的特性，分为最大堆和最小堆两种。</p>
<p><img alt="image" src="https://user-images.githubusercontent.com/87457873/129164812-fd68bc2c-0ac2-4a39-9e61-2e8dba2590a3.png" /></p>
<p>如上图可知，最小堆就是在这颗二叉树中，任何一个节点的值比其所在子树的任意一个节点都要小。最大堆就是在这颗二叉树中，任何一个节点的值都比起所在子树的任意一个节点值都要大。</p>
<p>那么如何构建一个堆呢？首先要将所有的元素构建为一个完全二叉树。完全二叉树是指除叶子节点，所有层级是满节点，叶子节点从左向右排列填满。</p>
<p>在一个完全二叉树中，将数据重新按照堆的的特性排列，就可以将完全二叉树变成一个堆。这个过程叫做“堆化”。</p>
<p>在堆中，我们要删除一个元素一般从堆顶删除（可以取到最大值/最小值）。删除之后，数据集就不能算作一个堆了，因为最顶层的元素没有了，数据集不符合完全二叉树的定义。这时，我们需要将堆的数据进行重新排列，也就是重新“堆化”。同样的，在堆中新添加一个元素也需要重新做“堆化”的操作，来将数据集恢复到满足堆定义的状态。</p>
<p>所以，在堆这种数据结构中，最重要的是“堆化”的这个算法操作。其次，堆化数据如何存储也是很重要的。接下来，详细说一下。</p>
<h1 id="_2">完全二叉树的存储方式</h1>
<p>对于二叉树来说，存储方式有2种，一种使用数组的形式来存储，一种使用链表的方式存储。同样的，这两种方式继承了这两种数据结构的坏处和好处。链表的方式相对浪费存储空间，因为要存储左右子树的指针，但扩缩容方便。而数组更加节省空间，更加方便定位节点，缺点则是扩缩容不便。</p>
<p>我们以数组的方式来做示例，了解存储的细节：</p>
<p><img alt="image" src="https://user-images.githubusercontent.com/87457873/129164881-e85eefca-214f-4c29-8dca-c70f932e30e6.png" /></p>
<p>我们不用 (index = 0) 的位置来存储数据，而是从 (index = 1) 开始，这样，对于任意一个节点 (i) 来说，就有 左节点 (2<em>i)，右节点 (2</em>i+1)，而父节点就是 (\frac i 2)。</p>
<h1 id="_3">堆的操作</h1>
<p>我们先介绍两种常用的堆操作：pop &amp; push，添加一个元素和删除一个元素。</p>
<p>假如我们有如下的一个最大堆，当我们添加了一个元素之后，就需要做“堆化”，使得堆满足定义。</p>
<p><img alt="image" src="https://user-images.githubusercontent.com/87457873/129164918-29214746-d409-4ab8-b753-6c6cb90d7c28.png" /></p>
<p>这种从堆底向上堆化的过程，叫做“从下到上堆化”。我把这个过程实现为代码，如下：</p>
<pre><code class="language-go">// 从下到上堆化
func (h *Heap) downToUpHeapify(pos int) {
    for pos / 2 &gt; 0 &amp;&amp; h.data[pos/2].Less(h.data[pos]) { // 如果存在父节点 &amp; 值大于父节点
        h.swap(pos, pos/2) // 交换两个值的位置
        pos = pos /2 // 将操作节点变为父节点的位置
    }
}
</code></pre>
<p>当我们想要从堆顶 pop 一个元素的时候。我们需要先将元素pop，然后把堆中最后一个元素放到堆顶，然后进行一次“堆化”。</p>
<p><img alt="image" src="https://user-images.githubusercontent.com/87457873/129164965-85c5afbd-686b-41bf-9ff4-257b8814ca87.png" /></p>
<p>这种从堆顶向下堆化的过程，叫做“从上到下堆化”。我把这个过程实现为代码，如下：</p>
<pre><code class="language-go">// 从上到下堆化
func (h *Heap) upToDownHeapify() {
    max := h.len
    i := 1
    pos := i
    for {
        if i * 2 &lt;= max &amp;&amp; h.data[i].Less(h.data[i*2]) { // 如果有左子树，且自己小于左子树
            pos = i*2 
        }

        if i *2 +1 &lt;= max &amp;&amp; h.data[pos].Less(h.data[i*2+1]) { // 如果有右子树，且自己小于右子树
            pos = i*2+1
        }
        if pos == i { // 如果位置没有变化，说明堆化结束
            break
        }

        h.swap(i, pos) // 交换当前位置和下一个位置的内容
        i = pos // 操作下一个位置
    }
}
</code></pre>
<h1 id="golang-containerheap">Golang 的 container.heap 包</h1>
<blockquote>
<p>注意，上述的讲述中，为了方便表示，我们在数组的索引0没有存储内容，从索引1开始存储。
而 Golang 的实现中，索引0 是存储了数据的。这样的话，每一个元素的左子树和右子树就分别变成了 (2<em>i+1) 和 (2</em>i+2)。</p>
</blockquote>
<p>Golang 的 Container.heap 是一个实现了通用最小堆的包。任何数据集只要实现了其 Interface 接口，即可使用这个包将其堆化，并进行一系列的操作。</p>
<pre><code class="language-go">type Interface interface {
    sort.Interface
  Push(x interface{}) // 把元素添加到 Len() 的位置
    Pop() interface{}   // 删除并返回 Len() - 1 的元素.
}

// sort.Interface
type Interface interface {
    // Len is the number of elements in the collection.
    Len() int
    // Less reports whether the element with
    // index i should sort before the element with index j.
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    Swap(i, j int)
}
</code></pre>
<p>Interface 的数据结构如上，要求实现 sort.Interface 和 Push Pop 两个方法。</p>
<p>sort.Interface 的定义，同样贴在了上面，主要是三个方法：</p>
<ul>
<li>Len 返回数据集的长度；</li>
<li>Less 返回 index i 是否小于 index j；</li>
<li>Swap 交换 index i 和 j 的值；</li>
</ul>
<p>接下来，我们看一下 Push 操作：</p>
<pre><code class="language-go">func Push(h Interface, x interface{}) {
    h.Push(x) // 向数据集添加一个元素
    up(h, h.Len()-1) // 从下向上堆化
}

// 从下向上堆化的内容
func up(h Interface, j int) {
  // h 表示堆，j 代表需要堆化的元素 index
    for {
        i := (j - 1) / 2 // 定义 j 的父 index
        if i == j || !h.Less(j, i) { // 如果两个元素相等 或者 父元素小于当前元素
            break  // 堆化完成
        }
        h.Swap(i, j) // 交换父元素和当前元素
        j = i // index 变为父元素的 index
    }
}
</code></pre>
<p>上面在 push 元素之后，做了 “从下到上”的堆化。</p>
<p>接下来，是 Pop 操作：</p>
<pre><code class="language-gp">// 返回堆顶的元素，并删掉它
func Pop(h Interface) interface{} {
  n := h.Len() - 1 // 获取最终堆长度（去掉最后一个元素）
    h.Swap(0, n)     // 交换堆顶和最后一个元素
    down(h, 0, n)    // 从上到下堆化
    return h.Pop()   // 弹出最后一个元素
}

func down(h Interface, i0, n int) bool {
    i := i0 // 堆顶 index
    for {
        j1 := 2*i + 1  // 左孩子 index
        if j1 &gt;= n || j1 &lt; 0 { // j1 大于堆长度 或 溢出
            break  // 堆化结束
        }
        j := j1 // j = 左孩子
        if j2 := j1 + 1; j2 &lt; n &amp;&amp; h.Less(j2, j1) { 
      // j2 = 右孩子；j 小于堆长度 &amp;&amp; 右孩子小于左孩子
            j = j2 // j = 2*i + 2 = 右孩子 
        }
    // 上面是从左右孩子选出小的那个，将 index 赋值给 j

        if !h.Less(j, i) { // 如果 堆顶小于 j , 堆化结束
            break
        }

        h.Swap(i, j) // 交换堆顶元素和 j
        i = j // 切换到下一个操作 index
    }

  // 返回 元素是否有移动
  // 此处是一个特殊设计，用来判断向下堆化是否真的有操作
  // 当删除中间的元素时，如果向下堆化没有操作的话，就需要再做向上堆化
    return i &gt; i0 
}
</code></pre>
<p>Golang 还提供了之前原理讲述中没有的方法： Remove Fix</p>
<ul>
<li>Remove 是删除堆中指定元素，不一定是堆顶；</li>
<li>Fix 是当某一个元素的值有变化时，用来重新堆化；</li>
</ul>
<pre><code class="language-go">func Remove(h Interface, i int) interface{} {
    n := h.Len() - 1 // 堆的长度
    if n != i { // 如果不是堆顶
        h.Swap(i, n) // 交换删除元素 和 最后一个元素
        if !down(h, i, n) { // 从上到下堆化
            up(h, i) // 如果没有成功，就从下岛上堆化
        }
    }
    return h.Pop() // 弹出最后一个元素
}

func Fix(h Interface, i int) {
  // i 是值被改变的 index
    if !down(h, i, h.Len()) {   // 从上到下堆化
        up(h, i) // 如果没有成功，就从下岛上堆化
    }
}
</code></pre>
<p>这里有一个内容需要注意，就是 Remove 中， (n = Len() -1) 来表示堆长度，而在 Fix 则使用 (n = Len()) 来表示。这是因为 Remove 中，最后一个元素是要被删除掉，所以最终的堆长度是 (Len() – 1)。</p>
<p>上面我们已经了解了 Golang 中，对于一个堆的所有操作。只剩下最后一个方法：Init，初始化一个数据集，变成堆。</p>
<pre><code class="language-go">func Init(h Interface) {
    n := h.Len()  // n 是堆长度
  // i = 最后一个非叶子节点的 index； i &gt;= 堆顶； index 自减
    for i := n/2 - 1; i &gt;= 0; i-- {
    // 从当前节点开始，从上到下堆化
        down(h, i, n)
    }
}
</code></pre>
<p>根据堆的特性可知，叶子节点不可以从上到下堆化。所以，我们找到最后非叶子节点的索引值，从这里开始做堆化操作。</p>
<p>至此，container.heap 包中的内容就全部讲解完毕。了解了堆的原理之后，其实会发现并不难理解。</p>
<h1 id="_4">堆的应用</h1>
<p>在堆排序中，就需要用到堆算法来将数据级堆化，然后一个个的弹出元素，以达到排序的目的。</p>
<p>堆也可以用于实现优先级队列。优先级队列在实际开发过程中有着广泛的应用。在很多时候，都可以用它来实现处理带优先级的事件，处理定时任务等等。</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme_extra.js" defer></script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
